// OpenTelemetry imports temporarily disabled
/*
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-grpc';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-grpc';
import { PeriodicExportingMetricReader } from '@opentelemetry/sdk-metrics';
import { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base';
import { diag, DiagConsoleLogger, DiagLogLevel } from '@opentelemetry/api';
*/

// Enable diagnostics for debugging
if (process.env.OTEL_DEBUG === 'true') {
  diag.setLogger(new DiagConsoleLogger(), DiagLogLevel.DEBUG);
}

const serviceName = process.env.OTEL_SERVICE_NAME || 'entrip-api';
const serviceVersion = process.env.SERVICE_VERSION || '1.0.0';
const deploymentEnvironment = process.env.DEPLOYMENT_ENV || 'production';

// Configure resource attributes
const resource = new Resource({
  [SemanticResourceAttributes.SERVICE_NAME]: serviceName,
  [SemanticResourceAttributes.SERVICE_VERSION]: serviceVersion,
  [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: deploymentEnvironment,
  [SemanticResourceAttributes.SERVICE_NAMESPACE]: 'entrip',
  'service.instance.id': process.env.HOSTNAME || 'local',
});

// Configure trace exporter (Tempo)
const traceExporter = new OTLPTraceExporter({
  url: process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT || 'http://tempo:4317',
  headers: {},
});

// Configure metric exporter
const metricExporter = new OTLPMetricExporter({
  url: process.env.OTEL_EXPORTER_OTLP_METRICS_ENDPOINT || 'http://tempo:4317',
  headers: {},
});

// Initialize OpenTelemetry SDK
const sdk = new NodeSDK({
  resource,
  spanProcessor: new BatchSpanProcessor(traceExporter),
  metricReader: new PeriodicExportingMetricReader({
    exporter: metricExporter,
    exportIntervalMillis: 10000, // Export metrics every 10 seconds
  }),
  instrumentations: [
    getNodeAutoInstrumentations({
      '@opentelemetry/instrumentation-fs': {
        enabled: false, // Disable fs instrumentation to reduce noise
      },
      '@opentelemetry/instrumentation-express': {
        requestHook: (span, request) => {
          // Add custom attributes to spans
          span.setAttribute('http.request.body.size', request.get('content-length') || 0);
          span.setAttribute('flight.api.version', 'v1');
          
          // Extract and add user context if available
          const userId = (request as any).user?.id;
          if (userId) {
            span.setAttribute('user.id', userId);
          }
        },
      },
      '@opentelemetry/instrumentation-http': {
        requestHook: (span, request) => {
          // Add trace ID to response headers for correlation
          const traceId = span.spanContext().traceId;
          if ((request as any).setHeader) {
            (request as any).setHeader('X-Trace-ID', traceId);
          }
        },
      },
    }),
  ],
});

// Graceful shutdown
process.on('SIGTERM', () => {
  sdk
    .shutdown()
    .then(() => console.log('OpenTelemetry SDK shut down successfully'))
    .catch((error) => console.error('Error shutting down SDK', error))
    .finally(() => process.exit(0));
});

export { sdk };

// Helper function to add trace context to logs
export function addTraceContext(message: string): string {
  const span = require('@opentelemetry/api').trace.getActiveSpan();
  if (span) {
    const spanContext = span.spanContext();
    return `[TraceID: ${spanContext.traceId}] ${message}`;
  }
  return message;
}

// Export tracing utilities
export { trace, context, SpanStatusCode } from '@opentelemetry/api';
export const tracer = require('@opentelemetry/api').trace.getTracer(serviceName, serviceVersion);